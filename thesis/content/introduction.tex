\chapter{Introduction}

The topic of design patterns and architectural styles are vital to the subject of software development. They empower inexperienced programmers to write maintainable applications and provide guidelines that may be adopted but are implemented in each application in one way or another. 

Many books are available on the topic of software design and architectural styles, on how to write maintainable and extensible applications. The books are written by software engineers with many years of experience , like Martin Fowler with his book \emph{Patterns of Enterprise Application Architecture} \footnote{IBAN: 978-0321127426}, Robert C. Martin with \emph{Agile Software Development. Principles, Patterns, and Practices} \footnote{IBAN: 978-0135974445} or \emph{Design Patterns. Elements of Reusable Object-Oriented Software} by John Vlissides, Richard Helm, Ralph Johnson and Erich Gamma \footnote{IBAN: 978-0201633610}. 

The same topics are to a certain degree taught at universities however they all lack one substantial flaw: While they propose some pattern, explain when it is applying and how to implement it, they do not provide any evidence that when using the pattern in a real-world application there is an advantage to gain.  Many patterns claim that they improve the extensibility and increase the decoupling of code however in most of the example code only the basic implementation is showed. The impact on the code when a extension is actually implemented is not being shown by the books which leaves the reader to believe the promises made by the author. 


While the patterns are in extensive use and thus have empirically proven themselves useful,the scientific research on this topic is far from being exhaustive. A study of 2008 was published at IEEE that tried to cover the effect of using design patterns in software development. This study came to the result that while the implementation of best practice methods in many cases enhanced some quality aspects while at the same time performing worse in other factors. It concluded that the use of patterns should be considered carefully as they lead to a certain trade-off.

Another study published covering a similar subject came to different results, concluding that the use of established design patterns in most of the cases led to a significant improvement of code quality, contradicting the previous study. \href{http://ieeexplore.ieee.org/abstract/document/4493325/?reload=true}{http://ieeexplore.ieee.org/abstract/document/4493325/?reload=true} and \href{http://www.sciencedirect.com/science/article/pii/S0950584911002151;}{http://www.sciencedirect.com/science/article/pii/S0950584911002151;}

It is hardly possible to perform scientific research on real-world software projects as there are only little ways for serious comparison. The patterns only provide a coarse guideline, the actual implementation largely depends on the use case and will vary substantially from application to application. Because of this most of the research is done via \emph{Controlled Experiments}, as is this thesis. Therefore it has to be said that most of this kind of studies are considered at least partially theoretical as a number of assumptions have to be made. The development of an application is highly subjective and depends on the coding style and experience of the engineer, code review policies can influence the quality as well.

However this thesis intends to give insights on how the use of well-established architectural and design pattern that claim to improve extensibility impact the code quality when this extensions are in fact implemented. This is done by developing two applications that are both designed to meet the same use cases and requirements. One is programmed by using established patterns while the other is developed without considerations regarding code quality while nevertheless implementing the same basic program structure in order to improve comparability.

After satisfying the basic requirements new features are being implemented, namely another type of persistence, a different kind of user interface and lastly means for caching data in the application to reduce the need of database queries. After realizing these changes in both programs the costs of implementing can be compared in both quantitative and qualitative ways. 

