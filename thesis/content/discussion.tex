\chapter{Discussion}
\label{sec:discussion}
In this chapter all data gathered in the last section is revisited and put into context. 
\section{Meaning and significance of the file count}
As clearly visible in section \ref{sec:file-count} the ad-hoc version of the program does not need as many files as the best practice implementation. This is mainly due to the missing interface files, as well as the files for repositories. Especially in phase 3, where a new database should be supported, this factor can be easily observed. In the ad-hoc version all code concerning the database interaction was put into existing classes, resulting in only one additional file while the best practice implementation needs to create and derive one file per repository. 

\section{Meaning and significance of the line count}
The same statement as above applies to the count of total lines as seen in section \ref{sec:line-count}. Each interface class consists of various method declarations that are counted as well. As stated in section \ref{sec:line-count} for better comparison in addition to the total line count for the best practice implementation another count was made excluding the \texttt{@Override}-Annotation lines as they bias the result. 

Here a interesting observation can be made for the line count: While the total count of the best practice version is higher for both phases 1 and two, the increase of lines is between the phases is significantly lower. While the best practice version added 2960 lines of code, the ad-hoc version added 3600 lines of code. This difference of about 700 lines does not seem much, however it has to be noted that this lines were mainly necessary because of case distinctions as can be seen in section \ref{sec:ad-hoc-javafx}. This reduces readability on the one hand and results in a greater risk of programming errors. 

The fact that the increase in lines between phase 2 and 3 is nearly the same is easily explained as the added files differ significantly. This is due to the overhead of declaring a class including its constructor and other programming-language-connected actions which lead to a high number of additions which are not necessary in the ad-hoc version.

Additionally to the lower number of files and the comparable number of lines in the two programs, the ad-hoc implementation on average contains noticeably more code per file. As the two implementations offer exactly the same functionality this means that responsibilities have shifted and each class is in charge of more actions. However this fact is a clear violation of the Single-Responsibility-Principle (see section \ref{sec:srp}) which may introduce more programming errors in the future. 

\section{Maintainability}
The biggest effect and difference when using design patterns and interfaces can be observed exactly in conforming of the Single-Responsibility-Principle and hence in the readability of the code. While each data class of the ad-hoc version does not only have the responsibility to encapsulate the data, it is responsible for saving the data to two different kinds of persistent storage. This results in a quite long file that mixes technologies and needs to be revisited any time a new persistent storage is added, existing storage technologies are changed or the data classes change. 

In the case of view frameworks due to missing use of interfaces asides from implementing the view using a new framework each and every class that depends on any kind of interface needs to be adopted. This is visible in table \ref{table:touched-files}, where is stated that the implementation of new technologies influences lower numbers of dependent files which is a very desired behaviour. 

In addition to the points mentioned above the metric of the code complexity which can be seen in section \ref{sec:complexity} clearly indicates a difference in the maintainability of the application. The cyclometric complexity states the independent paths in a program, a higher number indicates that the code is on the one hand difficult to understand and on the other hand is more likely to contain errors\footnote{\href{http://www.chambers.com.au/glossary/mc\_cabe\_cyclomatic\_complexity.php}{http://www.chambers.com.au/glossary/mc\_cabe\_cyclomatic\_complexity.php}}. Furthermore as some testing strategies are targeting to cover all paths of a program a higher code complexity may also lead to higher testing effort.

Similar to the results of the straight-forward line count the complexity development seen in table \ref{table:total-complexity} shows that while the initial complexity of the ad-hoc program version is slightly lower especially in the transition from phase 1 to phase 2 the complexity raises over-proportionally compared to the best-practice implementation. 
Also the code complexity per file as can be seen in table \ref{table:file-complexity} shows that due to the reduced number of files each file has a quite high complexity. This indicates that the classes are more difficult to understand and test which impacts maintainability negatively. 